/* tslint:disable */
/* eslint-disable */
/**
 * PreModeration
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';
import { createRequestFunction } from "../../helpers";

/**
 * Asin component which needs to be pre moderated.
 * @export
 * @interface AsinComponent
 */
export interface AsinComponent {
    /**
     * Type of the asin component.
     * @type {string}
     * @memberof AsinComponent
     */
    componentType: AsinComponentComponentTypeEnum;
    /**
     * Asin id to be pre moderated.
     * @type {string}
     * @memberof AsinComponent
     */
    asin: string;
    /**
     * Id of the component. The same will be returned as part of the response as well. This can be used to uniquely identify the component from the pre moderation response.
     * @type {string}
     * @memberof AsinComponent
     */
    id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AsinComponentComponentTypeEnum {
    LandingAsin = 'LANDING_ASIN',
    ProductAsin = 'PRODUCT_ASIN'
}

/**
 * Pre-moderation result for an Asin component
 * @export
 * @interface AsinComponentResponse
 */
export interface AsinComponentResponse {
    /**
     * The pre-moderation status of the component.
     * @type {string}
     * @memberof AsinComponentResponse
     */
    preModerationStatus?: AsinComponentResponsePreModerationStatusEnum;
    /**
     * Type of Asin component.
     * @type {string}
     * @memberof AsinComponentResponse
     */
    componentType?: AsinComponentResponseComponentTypeEnum;
    /**
     * A list of policy violations for the component that were detected during pre moderation. Note that this field is present in the response only when preModerationStatus is set to REJECTED.
     * @type {Array<AsinPolicyViolation>}
     * @memberof AsinComponentResponse
     */
    policyViolations?: Array<AsinPolicyViolation>;
    /**
     * Pre-moderated Asin Id.
     * @type {string}
     * @memberof AsinComponentResponse
     */
    asin?: string;
    /**
     * Id of the component. This is the same id sent as part of the request. This can be used to uniquely identify the component.
     * @type {string}
     * @memberof AsinComponentResponse
     */
    id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AsinComponentResponsePreModerationStatusEnum {
    Rejected = 'REJECTED',
    Approved = 'APPROVED',
    Failed = 'FAILED',
    RetryableFailure = 'RETRYABLE_FAILURE'
}
/**
    * @export
    * @enum {string}
    */
export enum AsinComponentResponseComponentTypeEnum {
    LandingAsin = 'LANDING_ASIN',
    ProductAsin = 'PRODUCT_ASIN'
}

/**
 * 
 * @export
 * @interface AsinPolicyViolation
 */
export interface AsinPolicyViolation {
    /**
     * A human-readable description of the policy.
     * @type {string}
     * @memberof AsinPolicyViolation
     */
    policyDescription?: string;
    /**
     * A policy violation code.
     * @type {string}
     * @memberof AsinPolicyViolation
     */
    name?: string;
    /**
     * Type of policy violation.
     * @type {string}
     * @memberof AsinPolicyViolation
     */
    type?: AsinPolicyViolationTypeEnum;
    /**
     * Address of the policy documentation. Follow the link to learn more about the specified policy.
     * @type {string}
     * @memberof AsinPolicyViolation
     */
    policyLinkUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AsinPolicyViolationTypeEnum {
    Warning = 'WARNING',
    Rejected = 'REJECTED'
}

/**
 * Date component which needs to be pre moderated. Either startDate or endDate must be populated, or both can be populated.
 * @export
 * @interface DateComponent
 */
export interface DateComponent {
    /**
     * Type of the date component.
     * @type {string}
     * @memberof DateComponent
     */
    componentType: DateComponentComponentTypeEnum;
    /**
     * End date of the component in yyyy-MM-dd HH:mm:ss format
     * @type {string}
     * @memberof DateComponent
     */
    endDate?: string;
    /**
     * Id of the component. The same will be returned as part of the response as well. This can be used to uniquely identify the component from the pre moderation response.
     * @type {string}
     * @memberof DateComponent
     */
    id: string;
    /**
     * Start date of the component in yyyy-MM-dd HH:mm:ss format
     * @type {string}
     * @memberof DateComponent
     */
    startDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DateComponentComponentTypeEnum {
    CampaignDate = 'CAMPAIGN_DATE'
}

/**
 * Pre-moderation result for a date component
 * @export
 * @interface DateComponentResponse
 */
export interface DateComponentResponse {
    /**
     * The pre-moderation status of the component.
     * @type {string}
     * @memberof DateComponentResponse
     */
    preModerationStatus?: DateComponentResponsePreModerationStatusEnum;
    /**
     * Type of the date component.
     * @type {string}
     * @memberof DateComponentResponse
     */
    componentType?: DateComponentResponseComponentTypeEnum;
    /**
     * End date of the component.
     * @type {string}
     * @memberof DateComponentResponse
     */
    endDate?: string;
    /**
     * A list of policy violations for the component that were detected during pre moderation. Note that this field is present in the response only when preModerationStatus is set to REJECTED.
     * @type {Array<DatePolicyViolation>}
     * @memberof DateComponentResponse
     */
    policyViolations?: Array<DatePolicyViolation>;
    /**
     * Id of the component. This is the same id sent as part of the request. This can be used to uniquely identify the component.
     * @type {string}
     * @memberof DateComponentResponse
     */
    id?: string;
    /**
     * Start date of the component.
     * @type {string}
     * @memberof DateComponentResponse
     */
    startDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DateComponentResponsePreModerationStatusEnum {
    Rejected = 'REJECTED',
    Approved = 'APPROVED',
    Failed = 'FAILED',
    RetryableFailure = 'RETRYABLE_FAILURE'
}
/**
    * @export
    * @enum {string}
    */
export enum DateComponentResponseComponentTypeEnum {
    CampaignDates = 'CAMPAIGN_DATES'
}

/**
 * 
 * @export
 * @interface DatePolicyViolation
 */
export interface DatePolicyViolation {
    /**
     * A human-readable description of the policy.
     * @type {string}
     * @memberof DatePolicyViolation
     */
    policyDescription?: string;
    /**
     * A policy violation code.
     * @type {string}
     * @memberof DatePolicyViolation
     */
    name?: string;
    /**
     * Type of policy violation.
     * @type {string}
     * @memberof DatePolicyViolation
     */
    type?: DatePolicyViolationTypeEnum;
    /**
     * Address of the policy documentation. Follow the link to learn more about the specified policy.
     * @type {string}
     * @memberof DatePolicyViolation
     */
    policyLinkUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DatePolicyViolationTypeEnum {
    Warning = 'WARNING',
    Rejected = 'REJECTED'
}

/**
 * Request structure of headline suggestion API.
 * @export
 * @interface HeadlineSuggestionRequest
 */
export interface HeadlineSuggestionRequest {
    /**
     * An array of ASINs associated with the creative. Note do not pass an empty array, this results in an error. 
     * @type {Array<string>}
     * @memberof HeadlineSuggestionRequest
     */
    asins?: Array<string>;
    /**
     * Maximum number of suggestions that API should return. Response will [0, maxNumSuggestions] suggestions (suggestions are not guaranteed).
     * @type {number}
     * @memberof HeadlineSuggestionRequest
     */
    maxNumSuggestions?: number;
    /**
     * 
     * @type {string}
     * @memberof HeadlineSuggestionRequest
     */
    adFormat?: HeadlineSuggestionRequestAdFormatEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum HeadlineSuggestionRequestAdFormatEnum {
    Brands = 'SPONSORED_BRANDS',
    BrandsSpotlight = 'SPONSORED_BRANDS_SPOTLIGHT'
}

/**
 * Response structure of headline suggestion API.
 * @export
 * @interface HeadlineSuggestionResponse
 */
export interface HeadlineSuggestionResponse {
    /**
     * An identifier for request made which is generated by server.
     * @type {string}
     * @memberof HeadlineSuggestionResponse
     */
    requestId?: string;
    /**
     * Suggestions are sorted, i.e., more suitable headline has lesser array index value
     * @type {Array<SuggestedHeadline>}
     * @memberof HeadlineSuggestionResponse
     */
    suggestions?: Array<SuggestedHeadline>;
}
/**
 * Image component which needs to be pre moderated. A publicly accessible imageUrl must be sent.
 * @export
 * @interface ImageComponent
 */
export interface ImageComponent {
    /**
     * Type of the image component.
     * @type {string}
     * @memberof ImageComponent
     */
    componentType: ImageComponentComponentTypeEnum;
    /**
     * Id of the component. The same will be returned as part of the response as well. This can be used to uniquely identify the component from the pre moderation response.
     * @type {string}
     * @memberof ImageComponent
     */
    id: string;
    /**
     * Url of the image to be pre moderated. The url must be publicly accessible.
     * @type {string}
     * @memberof ImageComponent
     */
    url: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageComponentComponentTypeEnum {
    BrandLogo = 'BRAND_LOGO',
    CustomImage = 'CUSTOM_IMAGE',
    OtherImage = 'OTHER_IMAGE'
}

/**
 * Pre moderation result for a image component
 * @export
 * @interface ImageComponentResponse
 */
export interface ImageComponentResponse {
    /**
     * The pre moderation status of the component.
     * @type {string}
     * @memberof ImageComponentResponse
     */
    preModerationStatus?: ImageComponentResponsePreModerationStatusEnum;
    /**
     * Type of the image component.
     * @type {string}
     * @memberof ImageComponentResponse
     */
    componentType?: ImageComponentResponseComponentTypeEnum;
    /**
     * A list of policy violations for the component that were detected during pre moderation. Note that this field is present in the response only when preModerationStatus is set to REJECTED.
     * @type {Array<ImagePolicyViolation>}
     * @memberof ImageComponentResponse
     */
    policyViolations?: Array<ImagePolicyViolation>;
    /**
     * Id of the component. This is the same id sent as part of the request. This can be used to uniquely identify the component.
     * @type {string}
     * @memberof ImageComponentResponse
     */
    id?: string;
    /**
     * Publicly accessible url of the image that got pre moderated.
     * @type {string}
     * @memberof ImageComponentResponse
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageComponentResponsePreModerationStatusEnum {
    Rejected = 'REJECTED',
    Approved = 'APPROVED',
    Failed = 'FAILED',
    RetryableFailure = 'RETRYABLE_FAILURE'
}
/**
    * @export
    * @enum {string}
    */
export enum ImageComponentResponseComponentTypeEnum {
    BrandLogo = 'BRAND_LOGO',
    CustomImage = 'CUSTOM_IMAGE',
    OtherImage = 'OTHER_IMAGE'
}

/**
 * Structure of a image evidence
 * @export
 * @interface ImageEvidence
 */
export interface ImageEvidence {
    /**
     * The top left Y-coordinate of the content that violates the specfied policy within the image.
     * @type {number}
     * @memberof ImageEvidence
     */
    topLeftY?: number;
    /**
     * The top left X-coordinate of the content that violates the specfied policy within the image.
     * @type {number}
     * @memberof ImageEvidence
     */
    topLeftX?: number;
    /**
     * The width of the content that violates the specfied policy within the image.
     * @type {number}
     * @memberof ImageEvidence
     */
    width?: number;
    /**
     * The height of the content that violates the specfied policy within the image.
     * @type {number}
     * @memberof ImageEvidence
     */
    height?: number;
}
/**
 * Structure of policy violation for a image component
 * @export
 * @interface ImagePolicyViolation
 */
export interface ImagePolicyViolation {
    /**
     * A human-readable description of the policy.
     * @type {string}
     * @memberof ImagePolicyViolation
     */
    policyDescription?: string;
    /**
     * List of evidences for the policy violations detected on the image component.
     * @type {Array<ImageEvidence>}
     * @memberof ImagePolicyViolation
     */
    imageEvidences?: Array<ImageEvidence>;
    /**
     * A policy violation code.
     * @type {string}
     * @memberof ImagePolicyViolation
     */
    name?: string;
    /**
     * Type of policy violation.
     * @type {string}
     * @memberof ImagePolicyViolation
     */
    type?: ImagePolicyViolationTypeEnum;
    /**
     * Address of the policy documentation. Follow the link to learn more about the specified policy.
     * @type {string}
     * @memberof ImagePolicyViolation
     */
    policyLinkUrl?: string;
    /**
     * Policy violation on an image can be detected on the ocr detected text on the image as well. This list of text evidences will have the policy violations detected on the text on top of the image.
     * @type {Array<TextEvidence>}
     * @memberof ImagePolicyViolation
     */
    textEvidences?: Array<TextEvidence>;
}

/**
    * @export
    * @enum {string}
    */
export enum ImagePolicyViolationTypeEnum {
    Warning = 'WARNING',
    Rejected = 'REJECTED'
}

/**
 * The Error Response Object.
 * @export
 * @interface ModerationError
 */
export interface ModerationError {
    /**
     * The HTTP status code of the response.
     * @type {string}
     * @memberof ModerationError
     */
    code?: string;
    /**
     * A human-readable description of the response.
     * @type {string}
     * @memberof ModerationError
     */
    details?: string;
}
/**
 * Components details that needs to be sent for pre moderation.
 * @export
 * @interface PreModerationRequest
 */
export interface PreModerationRequest {
    /**
     * Id of the brand/advertiser.
     * @type {string}
     * @memberof PreModerationRequest
     */
    recordId?: string;
    /**
     * Asin components which needs to be pre moderated.
     * @type {Array<AsinComponent>}
     * @memberof PreModerationRequest
     */
    asinComponents?: Array<AsinComponent>;
    /**
     * Type of Ad program to which this pre moderation components belong to.
     * @type {string}
     * @memberof PreModerationRequest
     */
    adProgram: PreModerationRequestAdProgramEnum;
    /**
     * Specifying locale will translate the premoderation message into that locale\'s associated language.     | Locale | Language (ISO 639) | Country (ISO 3166) |   |-----|-----|-------|   | ar-AE | Arabic (ar) | United Arab Emirates (AE) |   | zh-CN | Chinese (zh) | China (CN) |   | nl-NL | Dutch (nl) | Netherlands (NL) |   | en-AU | English (en) | Australia (AU) |   | en-CA | English (en) | Canada (CA) |   | en-IN | English (en) | India (IN) |   | en-GB | English (en) | United Kingdom (GB) |   | en-US | English (en) | United States (US) |   | fr-CA | French (fr) | Canada (CA) |   | fr-FR | French (fr) | France (FR) |   | de-DE | German (de) | Germany (DE) |   | it-IT | Italian (it) | Italy (IT) |   | ja-JP | Japanese (ja) | Japan (JP) |   | ko-KR | Korean (ko) | South Korea (KR) |   | pt-BR | Portuguese (pt) | Brazil (BR) |   | es-ES | Spanish (es) | Spain (ES) |   | es-US | Spanish (es) | United States (US) |   | es-MX | Spanish (es) | Mexico (MX) |   | tr-TR | Turkish (tr) | Turkey (TR) |   
     * @type {string}
     * @memberof PreModerationRequest
     */
    locale: PreModerationRequestLocaleEnum;
    /**
     * Image components which needs to be pre moderated.
     * @type {Array<ImageComponent>}
     * @memberof PreModerationRequest
     */
    imageComponents?: Array<ImageComponent>;
    /**
     * Date components which needs to be pre moderated.
     * @type {Array<DateComponent>}
     * @memberof PreModerationRequest
     */
    dateComponents?: Array<DateComponent>;
    /**
     * Text components which needs to be pre moderated.
     * @type {Array<TextComponent>}
     * @memberof PreModerationRequest
     */
    textComponents?: Array<TextComponent>;
    /**
     * Video components which needs to be pre moderated.
     * @type {Array<VideoComponent>}
     * @memberof PreModerationRequest
     */
    videoComponents?: Array<VideoComponent>;
}

/**
    * @export
    * @enum {string}
    */
export enum PreModerationRequestAdProgramEnum {
    SponsoredBrands = 'SPONSORED_BRANDS',
    SponsoredBrandsSpotlight = 'SPONSORED_BRANDS_SPOTLIGHT',
    SponsoredBrandsVideo = 'SPONSORED_BRANDS_VIDEO',
    Stores = 'STORES',
    SponsoredDisplay = 'SPONSORED_DISPLAY',
    Dsp = 'DSP'
}
/**
    * @export
    * @enum {string}
    */
export enum PreModerationRequestLocaleEnum {
    ArAe = 'ar-AE',
    ZhCn = 'zh-CN',
    NlNl = 'nl-NL',
    EnAu = 'en-AU',
    EnCa = 'en-CA',
    EnIn = 'en-IN',
    EnGb = 'en-GB',
    EnUs = 'en-US',
    FrCa = 'fr-CA',
    FrFr = 'fr-FR',
    DeDe = 'de-DE',
    ItIt = 'it-IT',
    JaJp = 'ja-JP',
    KoKr = 'ko-KR',
    PtBr = 'pt-BR',
    EsEs = 'es-ES',
    EsUs = 'es-US',
    EsMx = 'es-MX',
    TrTr = 'tr-TR'
}

/**
 * Information regarding the policy violations if present for the components, sent for pre moderation.
 * @export
 * @interface PreModerationResponse
 */
export interface PreModerationResponse {
    /**
     * Id of the brand/advertiser.
     * @type {string}
     * @memberof PreModerationResponse
     */
    recordId?: string;
    /**
     * Pre moderation result of the asin components. It will have information regarding the policy violations present if any.
     * @type {Array<AsinComponentResponse>}
     * @memberof PreModerationResponse
     */
    asinComponents?: Array<AsinComponentResponse>;
    /**
     * Unique Id for the moderation Request.
     * @type {string}
     * @memberof PreModerationResponse
     */
    preModerationId?: string;
    /**
     * Type of Ad program to which the pre moderation components belong to.
     * @type {string}
     * @memberof PreModerationResponse
     */
    adProgram?: PreModerationResponseAdProgramEnum;
    /**
     * Locale value that was passed in request.
     * @type {string}
     * @memberof PreModerationResponse
     */
    locale?: PreModerationResponseLocaleEnum;
    /**
     * Pre moderation result of the image components. It will have information regarding the policy violations present if any.
     * @type {Array<ImageComponentResponse>}
     * @memberof PreModerationResponse
     */
    imageComponents?: Array<ImageComponentResponse>;
    /**
     * Pre moderation result of the date components. It will have information regarding the policy violations present if any.
     * @type {Array<DateComponentResponse>}
     * @memberof PreModerationResponse
     */
    dateComponents?: Array<DateComponentResponse>;
    /**
     * Pre moderation result of the text components. It will have information regarding the policy violations present if any.
     * @type {Array<TextComponentResponse>}
     * @memberof PreModerationResponse
     */
    textComponents?: Array<TextComponentResponse>;
    /**
     * Pre moderation result of the video components. It will have information regarding the policy violations present if any.
     * @type {Array<VideoComponentResponse>}
     * @memberof PreModerationResponse
     */
    videoComponents?: Array<VideoComponentResponse>;
}

/**
    * @export
    * @enum {string}
    */
export enum PreModerationResponseAdProgramEnum {
    SponsoredBrands = 'SPONSORED_BRANDS',
    SponsoredBrandsSpotlight = 'SPONSORED_BRANDS_SPOTLIGHT',
    SponsoredBrandsVideo = 'SPONSORED_BRANDS_VIDEO',
    Stores = 'STORES',
    SponsoredDisplay = 'SPONSORED_DISPLAY',
    Dsp = 'DSP'
}
/**
    * @export
    * @enum {string}
    */
export enum PreModerationResponseLocaleEnum {
    ArAe = 'ar-AE',
    ZhCn = 'zh-CN',
    NlNl = 'nl-NL',
    EnAu = 'en-AU',
    EnCa = 'en-CA',
    EnIn = 'en-IN',
    EnGb = 'en-GB',
    EnUs = 'en-US',
    FrCa = 'fr-CA',
    FrFr = 'fr-FR',
    DeDe = 'de-DE',
    ItIt = 'it-IT',
    JaJp = 'ja-JP',
    KoKr = 'ko-KR',
    PtBr = 'pt-BR',
    EsEs = 'es-ES',
    EsUs = 'es-US',
    EsMx = 'es-MX',
    TrTr = 'tr-TR'
}

/**
 * Suggested Headline in response object.
 * @export
 * @interface SuggestedHeadline
 */
export interface SuggestedHeadline {
    /**
     * Unique Id of suggested headline.
     * @type {string}
     * @memberof SuggestedHeadline
     */
    headlineId?: string;
    /**
     * String that contains suggested headline.
     * @type {string}
     * @memberof SuggestedHeadline
     */
    headline?: string;
}
/**
 * Text component which needs to be pre moderated
 * @export
 * @interface TextComponent
 */
export interface TextComponent {
    /**
     * Type of text component.
     * @type {string}
     * @memberof TextComponent
     */
    componentType: TextComponentComponentTypeEnum;
    /**
     * Id of the component. The same will be returned as part of the response as well. This can be used to uniquely identify the component from the pre moderation response.
     * @type {string}
     * @memberof TextComponent
     */
    id: string;
    /**
     * Text which needs to be moderated.
     * @type {string}
     * @memberof TextComponent
     */
    text: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TextComponentComponentTypeEnum {
    Headline = 'HEADLINE',
    BrandName = 'BRAND_NAME',
    OtherText = 'OTHER_TEXT'
}

/**
 * Pre moderation result for a text component
 * @export
 * @interface TextComponentResponse
 */
export interface TextComponentResponse {
    /**
     * The pre moderation status of the component.
     * @type {string}
     * @memberof TextComponentResponse
     */
    preModerationStatus?: TextComponentResponsePreModerationStatusEnum;
    /**
     * Type of the text component.
     * @type {string}
     * @memberof TextComponentResponse
     */
    componentType?: TextComponentResponseComponentTypeEnum;
    /**
     * A list of corrected text without any policy violation. You could consider replacing the component with one of the corrected texts
     * @type {Array<string>}
     * @memberof TextComponentResponse
     */
    corrections?: Array<string>;
    /**
     * A list of policy violations for the component that were detected during pre moderation. Note that this field is present in the response only when preModerationStatus is set to REJECTED.
     * @type {Array<TextPolicyViolation>}
     * @memberof TextComponentResponse
     */
    policyViolations?: Array<TextPolicyViolation>;
    /**
     * Id of the component. This is the same id sent as part of the request. This can be used to uniquely identify the component.
     * @type {string}
     * @memberof TextComponentResponse
     */
    id?: string;
    /**
     * Text which got pre moderated.
     * @type {string}
     * @memberof TextComponentResponse
     */
    text?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TextComponentResponsePreModerationStatusEnum {
    Rejected = 'REJECTED',
    Approved = 'APPROVED',
    Failed = 'FAILED',
    RetryableFailure = 'RETRYABLE_FAILURE'
}
/**
    * @export
    * @enum {string}
    */
export enum TextComponentResponseComponentTypeEnum {
    Headline = 'HEADLINE',
    BrandName = 'BRAND_NAME',
    OtherText = 'OTHER_TEXT'
}

/**
 * Structure of a text evidence
 * @export
 * @interface TextEvidence
 */
export interface TextEvidence {
    /**
     * The specific text determined to violate the specified policy in reviewedText.
     * @type {string}
     * @memberof TextEvidence
     */
    violatingText?: string;
    /**
     * 
     * @type {TextEvidencePosition}
     * @memberof TextEvidence
     */
    position?: TextEvidencePosition;
}
/**
 * Position in the textComponent where the policy violation is detected.
 * @export
 * @interface TextEvidencePosition
 */
export interface TextEvidencePosition {
    /**
     * Zero-based index into the text in textComponent where the text specified in violatingText starts.
     * @type {number}
     * @memberof TextEvidencePosition
     */
    start?: number;
    /**
     * Zero-based index into the text in textComponent where the text specified in violatingText ends.
     * @type {number}
     * @memberof TextEvidencePosition
     */
    end?: number;
}
/**
 * Structure of policy violation for a text component
 * @export
 * @interface TextPolicyViolation
 */
export interface TextPolicyViolation {
    /**
     * A human-readable description of the policy.
     * @type {string}
     * @memberof TextPolicyViolation
     */
    policyDescription?: string;
    /**
     * A policy violation code.
     * @type {string}
     * @memberof TextPolicyViolation
     */
    name?: string;
    /**
     * Type of policy violation.
     * @type {string}
     * @memberof TextPolicyViolation
     */
    type?: TextPolicyViolationTypeEnum;
    /**
     * Address of the policy documentation. Follow the link to learn more about the specified policy.
     * @type {string}
     * @memberof TextPolicyViolation
     */
    policyLinkUrl?: string;
    /**
     * List of text evidences
     * @type {Array<TextEvidence>}
     * @memberof TextPolicyViolation
     */
    textEvidences?: Array<TextEvidence>;
}

/**
    * @export
    * @enum {string}
    */
export enum TextPolicyViolationTypeEnum {
    Warning = 'WARNING',
    Rejected = 'REJECTED'
}

/**
 * Video component which needs to be pre moderated. A publicly accessible videoUrl must be sent.
 * @export
 * @interface VideoComponent
 */
export interface VideoComponent {
    /**
     * Type of the video component.
     * @type {string}
     * @memberof VideoComponent
     */
    componentType: VideoComponentComponentTypeEnum;
    /**
     * Id of the component. The same will be returned as part of the response as well. This can be used to uniquely identify the component from the pre moderation response.
     * @type {string}
     * @memberof VideoComponent
     */
    id: string;
    /**
     * Url of the video to be pre moderated. The url must be publicly accessible.
     * @type {string}
     * @memberof VideoComponent
     */
    url: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VideoComponentComponentTypeEnum {
    SponsoredBrandsVideo = 'SPONSORED_BRANDS_VIDEO',
    OtherVideo = 'OTHER_VIDEO'
}

/**
 * Pre moderation result for a video component
 * @export
 * @interface VideoComponentResponse
 */
export interface VideoComponentResponse {
    /**
     * The pre moderation status of the component.
     * @type {string}
     * @memberof VideoComponentResponse
     */
    preModerationStatus?: VideoComponentResponsePreModerationStatusEnum;
    /**
     * Type of the video component.
     * @type {string}
     * @memberof VideoComponentResponse
     */
    componentType?: VideoComponentResponseComponentTypeEnum;
    /**
     * A list of policy violations for the component that were detected during pre moderation. Note that this field is present in the response only when preModerationStatus is set to REJECTED.
     * @type {Array<VideoPolicyViolation>}
     * @memberof VideoComponentResponse
     */
    policyViolations?: Array<VideoPolicyViolation>;
    /**
     * Id of the component. This is the same id sent as part of the request. This can be used to uniquely identify the component.
     * @type {string}
     * @memberof VideoComponentResponse
     */
    id?: string;
    /**
     * Publicly accessible url of the video that got pre moderated.
     * @type {string}
     * @memberof VideoComponentResponse
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VideoComponentResponsePreModerationStatusEnum {
    Rejected = 'REJECTED',
    Approved = 'APPROVED',
    Failed = 'FAILED',
    RetryableFailure = 'RETRYABLE_FAILURE'
}
/**
    * @export
    * @enum {string}
    */
export enum VideoComponentResponseComponentTypeEnum {
    SponsoredBrandsVideo = 'SPONSORED_BRANDS_VIDEO',
    OtherVideo = 'OTHER_VIDEO'
}

/**
 * Structure of a video evidence
 * @export
 * @interface VideoEvidence
 */
export interface VideoEvidence {
    /**
     * The start position (in seconds) of the content that violates the specified policy within the video.
     * @type {number}
     * @memberof VideoEvidence
     */
    start?: number;
    /**
     * The end position (in seconds) of the content that violates the specified policy within the video.
     * @type {number}
     * @memberof VideoEvidence
     */
    end?: number;
}
/**
 * Structure of policy violation for a video component
 * @export
 * @interface VideoPolicyViolation
 */
export interface VideoPolicyViolation {
    /**
     * A human-readable description of the policy.
     * @type {string}
     * @memberof VideoPolicyViolation
     */
    policyDescription?: string;
    /**
     * List of evidences for the policy violations detected on the video component.
     * @type {Array<VideoEvidence>}
     * @memberof VideoPolicyViolation
     */
    videoEvidences?: Array<VideoEvidence>;
    /**
     * A policy violation code.
     * @type {string}
     * @memberof VideoPolicyViolation
     */
    name?: string;
    /**
     * Type of policy violation.
     * @type {string}
     * @memberof VideoPolicyViolation
     */
    type?: VideoPolicyViolationTypeEnum;
    /**
     * Address of the policy documentation. Follow the link to learn more about the specified policy.
     * @type {string}
     * @memberof VideoPolicyViolation
     */
    policyLinkUrl?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VideoPolicyViolationTypeEnum {
    Warning = 'WARNING',
    Rejected = 'REJECTED'
}


/**
 * PreModerationApi - axios parameter creator
 * @export
 */
export const PreModerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API will be accepting different components of the ad/page and will be automatically validating the components and send back the policy violations if any. We recommend to send all components of the same entity to be sent together. It will make us better detect any policy violation if present. This will increase the Time to go live for the entity. In one request please don\'t send the components of more than one entity.
         * @summary Pre moderate the components
         * @param {string} amazonAdvertisingAPIClientId The identifier of a client associated with a \&quot;Login with Amazon\&quot; account.
         * @param {string} amazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use &#x60;GET&#x60; method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
         * @param {PreModerationRequest} preModerationRequest Request body for preModeration API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preModeration: async (amazonAdvertisingAPIClientId: string, amazonAdvertisingAPIScope: string, preModerationRequest: PreModerationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'amazonAdvertisingAPIClientId' is not null or undefined
            assertParamExists('preModeration', 'amazonAdvertisingAPIClientId', amazonAdvertisingAPIClientId)
            // verify required parameter 'amazonAdvertisingAPIScope' is not null or undefined
            assertParamExists('preModeration', 'amazonAdvertisingAPIScope', amazonAdvertisingAPIScope)
            // verify required parameter 'preModerationRequest' is not null or undefined
            assertParamExists('preModeration', 'preModerationRequest', preModerationRequest)
            const localVarPath = `/preModeration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amazonAdvertisingAPIClientId !== undefined && amazonAdvertisingAPIClientId !== null) {
                localVarHeaderParameter['Amazon-Advertising-API-ClientId'] = String(amazonAdvertisingAPIClientId);
            }

            if (amazonAdvertisingAPIScope !== undefined && amazonAdvertisingAPIScope !== null) {
                localVarHeaderParameter['Amazon-Advertising-API-Scope'] = String(amazonAdvertisingAPIScope);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preModerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreModerationApi - functional programming interface
 * @export
 */
export const PreModerationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PreModerationApiAxiosParamCreator(configuration)
    return {
        /**
         * This API will be accepting different components of the ad/page and will be automatically validating the components and send back the policy violations if any. We recommend to send all components of the same entity to be sent together. It will make us better detect any policy violation if present. This will increase the Time to go live for the entity. In one request please don\'t send the components of more than one entity.
         * @summary Pre moderate the components
         * @param {string} amazonAdvertisingAPIClientId The identifier of a client associated with a \&quot;Login with Amazon\&quot; account.
         * @param {string} amazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use &#x60;GET&#x60; method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
         * @param {PreModerationRequest} preModerationRequest Request body for preModeration API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preModeration(amazonAdvertisingAPIClientId: string, amazonAdvertisingAPIScope: string, preModerationRequest: PreModerationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreModerationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preModeration(amazonAdvertisingAPIClientId, amazonAdvertisingAPIScope, preModerationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PreModerationApi - factory interface
 * @export
 */
export const PreModerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PreModerationApiFp(configuration)
    return {
        /**
         * This API will be accepting different components of the ad/page and will be automatically validating the components and send back the policy violations if any. We recommend to send all components of the same entity to be sent together. It will make us better detect any policy violation if present. This will increase the Time to go live for the entity. In one request please don\'t send the components of more than one entity.
         * @summary Pre moderate the components
         * @param {string} amazonAdvertisingAPIClientId The identifier of a client associated with a \&quot;Login with Amazon\&quot; account.
         * @param {string} amazonAdvertisingAPIScope The identifier of a profile associated with the advertiser account. Use &#x60;GET&#x60; method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
         * @param {PreModerationRequest} preModerationRequest Request body for preModeration API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preModeration(amazonAdvertisingAPIClientId: string, amazonAdvertisingAPIScope: string, preModerationRequest: PreModerationRequest, options?: any): AxiosPromise<PreModerationResponse> {
            return localVarFp.preModeration(amazonAdvertisingAPIClientId, amazonAdvertisingAPIScope, preModerationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for preModeration operation in PreModerationApi.
 * @export
 * @interface PreModerationApiPreModerationRequest
 */
export interface PreModerationApiPreModerationRequest {
    /**
     * The identifier of a client associated with a \&quot;Login with Amazon\&quot; account.
     * @type {string}
     * @memberof PreModerationApiPreModeration
     */
    readonly amazonAdvertisingAPIClientId: string

    /**
     * The identifier of a profile associated with the advertiser account. Use &#x60;GET&#x60; method on Profiles resource to list profiles associated with the access token passed in the HTTP Authorization header.
     * @type {string}
     * @memberof PreModerationApiPreModeration
     */
    readonly amazonAdvertisingAPIScope: string

    /**
     * Request body for preModeration API.
     * @type {PreModerationRequest}
     * @memberof PreModerationApiPreModeration
     */
    readonly preModerationRequest: PreModerationRequest
}

/**
 * PreModerationApi - object-oriented interface
 * @export
 * @class PreModerationApi
 * @extends {BaseAPI}
 */
export class PreModerationApi extends BaseAPI {
    /**
     * This API will be accepting different components of the ad/page and will be automatically validating the components and send back the policy violations if any. We recommend to send all components of the same entity to be sent together. It will make us better detect any policy violation if present. This will increase the Time to go live for the entity. In one request please don\'t send the components of more than one entity.
     * @summary Pre moderate the components
     * @param {PreModerationApiPreModerationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreModerationApi
     */
    public preModeration(requestParameters: PreModerationApiPreModerationRequest, options?: any) {
        return PreModerationApiFp(this.configuration).preModeration(requestParameters.amazonAdvertisingAPIClientId, requestParameters.amazonAdvertisingAPIScope, requestParameters.preModerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


